from typing import Union, List

import nevergrad
import torch
from nevergrad.optimization import Optimizer
from secmlt.adv.evasion.base_evasion_attack import BaseEvasionAttack
from secmlt.models.base_model import BaseModel
from secmlt.optimization.constraints import Constraint
from secmlt.optimization.initializer import Initializer
from secmlt.trackers import Tracker

from secmlware.manipulations.replacement import ByteManipulation
from secmlware.optim.base import BaseByteOptimizer
from secmlware.optim.optimizer_factory import OPTIM_TYPE

DELTA_TYPE = Union[torch.Tensor, nevergrad.p.Array]


class MalwareAttack(BaseEvasionAttack):
    @classmethod
    def _trackers_allowed(cls):
        return True

    @staticmethod
    def get_perturbation_models():
        pass

    def __init__(
        self,
        y_target: Union[int, None],
        query_budget: int,
        loss_function: Union[str, torch.nn.Module],
        optimizer_cls: OPTIM_TYPE,
        manipulation_function: ByteManipulation,
        initializer: Initializer,
        trackers: Union[List[Tracker], Tracker] = None,
    ):
        self.y_target = y_target
        self.query_budget = query_budget
        self.loss_function = loss_function
        self.manipulation_function = manipulation_function
        self.initializer = initializer
        self.trackers = trackers
        self.optimizer = None
        self.optimizer_cls = optimizer_cls

    def _init_attack_manipulation(
        self, samples: torch.Tensor
    ) -> (torch.Tensor, DELTA_TYPE):
        return self.manipulation_function.initialize(samples.data)

    def _apply_manipulation(
        self, x: torch.Tensor, delta: DELTA_TYPE
    ) -> (torch.Tensor, torch.Tensor):
        raise NotImplementedError()

    def _optimizer_step(self, delta: DELTA_TYPE, loss: torch.Tensor) -> DELTA_TYPE:
        raise NotImplementedError()

    def _init_optimizer(
        self, model: BaseModel, delta: DELTA_TYPE
    ) -> Union[BaseByteOptimizer, Optimizer]:
        raise NotImplementedError()

    def _consumed_budget(self):
        raise NotImplementedError()

    def _get_best_delta(self):
        raise NotImplementedError()

    def _track(
        self,
        iteration: int,
        loss: torch,
        scores: torch.Tensor,
        x_adv: torch.Tensor,
        delta: DELTA_TYPE,
    ):
        if self._trackers_allowed():
            if self.trackers:
                for tracker in self.trackers:
                    tracker.track(
                        iteration=iteration,
                        loss=loss.data,
                        scores=scores.data,
                        x_adv=x_adv.data,
                        delta=delta,
                        grad=None,
                    )

    def _run(
        self,
        model: BaseModel,
        samples: torch.Tensor,
        labels: torch.Tensor,
        **optim_kwargs,
    ) -> (torch.Tensor, DELTA_TYPE):
        multiplier = 1 if self.y_target is not None else -1
        target = (
            torch.zeros_like(labels) + self.y_target
            if self.y_target is not None
            else labels
        ).type(labels.dtype)
        target = target.to(labels.device)
        x_adv, delta = self._init_attack_manipulation(samples)
        self.optimizer = self._init_optimizer(model, delta)
        budget = 0
        while budget < self.query_budget:
            x_adv, _ = self._apply_manipulation(samples, delta)
            scores = model.decision_function(x_adv)
            loss = self.loss_function(scores, target) * multiplier
            delta = self._optimizer_step(delta, loss)
            budget += self._consumed_budget()
            self._track(budget, loss, scores, x_adv, delta)
        # best_delta = self._get_best_delta()
        best_x, _ = self._apply_manipulation(samples, delta)
        return best_x, delta
